//참고 자료:
  이현창, 뇌를 자극하는 C++ 프로그래밍, 한빛미디어, 2006.7.6

<객체지향 프로그래밍>

*객체지향 프로그래밍이란?

객체 지향 프로그래밍은 프로그램을 구성하는 각각의 기능들을 '객체'로 나누어 개발하고, 완성된 각각의 객체들을 모아서 조립하는 방식의 프로그래밍이다.

-객체지향 프로그래밍의 장점

1. 객체는 독립성을 지니고있어, 다른 객체에 대한 기술 정보를 몰라도, 현재 만들고 있는 객체에 지장이 없다.
2. 완성된 프로그램에 문제가 생겼을 경우, 문제가 발생한 부분의 객체만 확인하여 수정하면 된다.
3. 다른 종류의 프로그램에 재사용이 가능하여 재사용성이 높다.

객체지향 프로그래밍을 사용할때, 연결할 객체들의 연결장치 부분을 '인터페이스'라고 하는데, 이 인터페이스 끼리는 서로 약속이 되어있어야한다. 

*클래스와 객체

클래스와 객체는 '제품 설계도'와 '제품'의 관계로 볼 수 있다. 
클래스는 관련된 변수와 함수들을 하나의 가방에 모아놓은 것이다. 클래스는 구조체와 마찬가지로 사용자 정의 타입을 만들수있다.

객체는 클래스를 사용해서 정의한 변수이다. 객체에는 클래스에서 명시해준 변수와 함수들이 들어있어, 객체는 이것들을 사용하여 임무를 수행할 수 있다.

*정보 은닉과 캡슐화

정보 은닉은 다른 객체의 정보를 숨기는 것이다. 정보 은닉은 다른 객체가 어떻게 구현되어 있는지 반드시 모르도록 강요하는 의미를 담고 있다.
객체들이 서로의 내부 구현에 대해 알아, 그 사실에 의존해서 객체를 만들게 될 경우 문제가 발생할 수 있기 때문에 정보 은닉을 한다.

캡슐화는 객체끼리의 약속된 부분을 제외한 나머지 부분을 정보 은닉하는 것을 말한다. 

*상속과 다형성

상속은 기존의 클래스를 토대로 새로운 클래스를 만드는 방법이다. 상속한 클래스와 상속받은 클래스는 '부모 클래스'와 '자식 클래스'의 관계가 된다.

객체들간의 인터페이스만 유지한다면 얼마든지 객체를 갈아 끼울 수 있는 성질을 다형성이라고 한다. 

<클래스와 객체의 기본>

*클래스의 정의

Point 클래스를 정의하며 클래스의 기본적인 기능을 알아보자.

#include <iostream>
using namespace std;

//Point 클래스를 정의한다
class Point
{
public //접근 제어와 관련된 키워드

  //멤버 변수들
  int x, y;
  
  //멤버 함수
  void Print{}
  {
    cout << "(" << x << "," << y << ")\n;
   }
}

멤버 변수는 클래스에 담기는 각 변수들을 말한다. 구조체의 멤버에서 이름만 바뀐것이다.
멤버 함수는 클래스에 담기는 함수이다.
접근제어는 클래스의 외부에서 멤버에 접근할 수 있는지 설정하는 것을 의미하는데, 멤버별로 접근 가능의 여부를 세세하게 설정이 가능하다. 
이 기능은 정보 은닉과 관련이 있다.

*객체의 생성과 사용

객체를 생성하고 멤버 변수, 멤버 함수를 사용하는 방법을 알아보자.

#include <iostream>
using namespace std;

//Point 클래스를 정의한다
class Point
{
public //접근 제어와 관련된 키워드

  //멤버 변수들
  int x, y;
  
  //멤버 함수
  void Print{}
  {
    cout << "(" << x << "," << y << ")\n;
   }
}

int main()
{
  //객체를 생성한다. 
  Point pt1, pt2;
  
  //pt1, pt2를 초기화 한다.
  pt1.x = 100;
  pt1.y = 100;
  pt2.x = 200;
  pt2.y = 200;
  
  //pt1, pt2의 내용을 출력한다.
  pt1.Print();
  pt2.Print();
  
  return 0;
}

멤버 변수와 멤버 함수에 접근하는 것은 구조체의 것과 다르지 않다.
객체의 외부에서 멤버 변수들에 접근하기 위해서는 pt1.x처럼 "어떤 객체의 x, y를 의미하는지"를 명시해줄 필요가 있지만, 멤버 함수 안에서는 
그냥 x, y라고 해도 된다. 어차피 자기 것이기 때문이다.

*멤버 함수

-일반 함수와 멤버 함수의 차이점

멤버함수는 일반함수와 같이 오버로드할 수도 있고, 디폴트 인자를 사용할 수도 있지만, 클래스의 멤버기 때문에 다음과 같은 차이점이 있다.

1. 멤버 함수를 호출하기 위해서는 객체의 이름을 명시해주어야한다.
2. 멤버 함수 안에서는 객체의 이름을 명시하지 않고 멤버 변수에 접근할 수 있다.
3. 멤버 함수 안에서는 외부에서 접근을 거부한 멤버에도 접근할 수 있다.

-멤버 함수의 위치

멤버 함수를 클래스 밖에서 정의할 수도 있다. 이렇게 하면 클래스의 정의부분을 보다 간결하게 유지할 수 있다.
멤버 함수를 클래스 밖에서 정의하려면 다음의 두 가지를 하면 된다.

1. 클래스 정의 안에서는 멤버 함수의 원형만 남겨둔다.
2. 클래스 정의 밖에서는 범위 지정 연산자(::)를 사용해서 함수를 정의한다.
    void Print()와 같이 적어주면 일반 함수의 정의와 혼동되기 때문에 void Point::Print()와 같이 적어준다.
    
-멤버 함수 안에서의 이름 충돌

멤버 함수 안에서 멤버 변수와 같은 이름의 변수를 정의할 경우, 멤버 함수 안에서는 멤버 변수를 사용할 수 없으므로 
멤버 변수와 같은 이름의 변수를 만들지 않는 것이 좋다.

-객체를 사용한 초기화와 대입

객체를 사용한 초기화나 대입은 구조체와 같이, 모든 멤버 변수의 값을 1:1 대입하는 방식이다. 
이때 멤버 함수는 어차피 값을 넣고 뺄 수 있는 개념이 아니기 때문에, 고려할 필요가 없다. 

*생성자와 소멸자

생성자는 객체를 생성할 때 자동적으로 호출되는 멤버 함수이고, 소멸자는 객체가 소멸될 때 자동으로 호출되는 멤버 함수이다.
보통 생성자는 '준비', 소멸자에서는 '정리' 하는 일을 한다.

*생성자의 사용

-디폴트 생성자

Point 클래스에 디폴트 생성자를 추가하여 생성자가 어떻게 생긴 것이며, 우리에게 어떤 이익을 줄 수 있는지 알아보자.

#include <iostream>
using namespace std;

//Point 클래스를 정의한다
class Point
{
public:
  //멤버 변수
  int x, y;
  
  //멤버 함수
  void Print();
  
  //생성자 
  Point();
};

Point::Point()
{
  x = 0;
  y = 0;
}
  
void Point::Print()
{
   cout << "(" << x << "," << y << ")\n;
}


int main()
{
  //객체를 생성한다. 
  Point pt;
  
  //pt의 내용을 출력한다.
  pt.Print();
  
  return 0;
}

생성자는 다음과 같은 특징이 있다.

1. 생성자는 클래스와 동일한 이름이다.
2. 생성자는 반환값이 없다.
3. 클래스의 바깥쪽에 선언할 때에는 영역 지정 연산자를 사용해서 적어주어야 한다.

위 코드를 보면 객체 pt를 생성할때, 생성자가 자동으로 호출되어 x, y의 값을 0으로 초기화한다.
위와 같이 아무런 인자가 없는 생성자를 디폴트 생성자라고 부른다.
만약에 생성자가 존재하지 않았다면 우리는 매번 객체를 생성할 때마다 x, y를 따로 초기화해주어야 했을 것이다.

-인자가 있는 생성자

인자가 있는 생성자는 말 그대로 Point(int X, int Y); 와 같이 인자를 하나 이상 가지고 있는 생성자를 말한다.
생성자는 객체를 생성할 때 호출되기 때문에 인자를 넘겨주는 것도 객체를 생성할 때 해주어야 한다.
인자가 있는 생성자를 호출하기 위해서 객체를 생성할 때 인자를 넣어준다.
인자를 가진 생성자는 오버로드가 가능하다.

-복사 생성자

복사 생성자는 다른 객체로부터 값을 복사해서 초기화하는 데 사용한다. 
